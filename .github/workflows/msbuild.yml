name: Build, Test, and Analyze

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  # Path to the solution file relative to the root of the project.
  SOLUTION_FILE_PATH: .

  UNITY_SOLUTION_FILE_PATH: ../XLGearModifier.Gear/XLGearModifier.Gear.sln

  # Configuration type to build.
  # You can convert this to a build matrix if you need coverage of multiple configuration types.
  # https://docs.github.com/actions/learn-github-actions/managing-complex-workflows#using-a-build-matrix
  BUILD_CONFIGURATION: Release
  UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
  
  package_path: "~/XLGearModifier_SDK.2.0.0.unitypackage"

jobs:
  check-paths-changed:
    name: Check Paths Changed
    runs-on: ubuntu-latest
    
    outputs:
      generate_unitypackage: ${{ steps.changes.outputs.unity_assemblies_changed }}
      build_asset_bundles: ${{ steps.changes.outputs.asset_bundles_changed }}
      build_mod: ${{ steps.changes.outputs.mod_changed }}

    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v3

      - name: Paths Changed Filter
        id: changes
        uses: dorny/paths-filter@v2.10.2
        with:
          filters: |
            unity_assemblies_changed:
              - './XLGearModifier.Gear/Assets/Scripts/**'
              - './XLGearModifier.Gear/Assets/Editor/**'
            asset_bundles_changed:
              - './XLGearModifier.Gear/Assets/Gear Done/**'
              - './XLGearModifier.Gear/Assets/Gear Temp/**'
              - './XLGearModifier.Gear/Assets/UserInterface/**'
            mod_changed:
              - './XLGearModifier/**'

  build-unity-assemblies:
    name: Build XLGearModifier.Unity & XLGearModifier.Unity.Editor
    runs-on: windows-latest
    needs: check-paths-changed
    if: needs.check-paths-changed.outputs.generate_unitypackage == 'true'
    
    steps:
    - uses: actions/checkout@v2
      with:
        fetch-depth: 0

    - name: Add MSBuild to PATH
      uses: microsoft/setup-msbuild@v1

    - name: Build 
      working-directory: ${{env.GITHUB_WORKSPACE}}
      shell: powershell
      run: |
        msbuild /m /p:Configuration=${{env.BUILD_CONFIGURATION}} ${{env.UNITY_SOLUTION_FILE_PATH}}

    - name: Copy DLLs to Destinations
      run: |
        Copy-Item "XLGearModifier.Gear/Temp/bin/${{env.BUILD_CONFIGURATION}}/XLGearModifier.Unity.dll" -Destination "XLGearModifier/References/XLGearModifier.Unity.dll"
        Copy-Item "XLGearModifier.Gear/Temp/bin/${{env.BUILD_CONFIGURATION}}/XLGearModifier.Unity.dll" -Destination "XLGearModifier.Gear/Assets/XLGM_SDK/XLGearModifier.Unity.dll"
        Copy-Item "XLGearModifier.Gear/Temp/bin/${{env.BUILD_CONFIGURATION}}/XLGearModifier.Unity.Editor.dll" -Destination "XLGearModifier.Gear/Assets/XLGM_SDK/XLGearModifier.Unity.Editor.dll"

    - name: Commit New DLLs
      run: |
        git config user.name "GitHub Actions"
        git config user.email "<>"
        git commit -m "Updating Unity assemblies" ./XLGearModifier/References/XLGearModifier.Unity.dll ./XLGearModifier.Gear/Assets/XLGM_SDK/XLGearModifier.Unity.dll ./XLGearModifier.Gear/Assets/XLGM_SDK/XLGearModifier.Unity.Editor.dll 

    # Copy DLL(s) into References folder and into Unity proj
    # Commit them?

  create-unity-package:
    name: Create SDK Unity Package
    runs-on: ubuntu-latest
    needs: build-unity-assemblies
    if: needs.check-paths-changed.outputs.unity_assemblies_changed == 'true'

    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v3
      - uses: actions/setup-dotnet@v2
    
      # Install the packager. We are putting it outside the working directory so we dont include it by mistake
      - name: Install Unity Packager
        run: |
          git clone https://github.com/Lachee/Unity-Package-Exporter.git "../tools/unity-package-exporter"
          dotnet publish -c Release -o ../tools "../tools/unity-package-exporter/UnityPackageExporter"
          
      # Pack the assets
      - name: Package Project
        run: |
          echo "Creating package ${{env.package_path}}"
          dotnet ../tools/UnityPackageExporter.dll --input ./XLGearModifier.Gear/Aseets/XLGM_SDK/ --output ${{env.package_path}}
          
      # Upload artifact
      - name: Upload Artifact
        uses: actions/upload-artifact@v3.0.0
        with:
          name: XLGearModifier_SDK.2.0.0.unitypackage
          path: ${{env.package_path}}   
        
  build-asset-bundles:
    name: Build Asset Bundles
    runs-on: ubuntu-latest
    needs: build-unity-assemblies
    if: needs.check-paths-changed.outputs.build_asset_bundles == 'true'

    steps:
    - uses: actions/checkout@v2
      with:
        fetch-depth: 0

    - name: Unity - Builder
      uses: game-ci/unity-builder@v2.0.4
      with:
        # Platform that the build should target.
        targetPlatform: # default is 
        # Version of unity to use for building the project. Use "auto" to get from your ProjectSettings/ProjectVersion.txt
        unityVersion: # optional, default is auto
        # Specific docker image that should be used for building the project
        customImage: # optional, default is 
        # Relative path to the project to be built.
        projectPath: # optional, default is 
        # Name of the build.
        buildName: # optional, default is 
        # Path where the builds should be stored.
        buildsPath: # optional, default is 
        # Path to a Namespace.Class.StaticMethod to run to perform the build.
        buildMethod: # optional, default is 
        # Custom parameters to configure the build.
        customParameters: # optional, default is 
        # The versioning scheme to use when building the project
        versioning: # optional, default is Semantic
        # The version, when used with the "Custom" versioning scheme
        version: # optional, default is 
        # Github private token to pull from github
        gitPrivateToken: # optional, default is 
        # User and optionally group (user or user:group or uid:gid) to give ownership of the resulting build artifacts
        chownFilesTo: # optional, default is 
        # Allows the branch of the build to be dirty, and still generate the build.
        allowDirtyBuild: # optional, default is 
        # run a post build job in yaml format with the keys image, secrets (name, value object array), command string
        postBuildSteps: # optional, default is 
        # Run a pre build job after the repository setup but before the build job (in yaml format with the keys image, secrets (name, value object array), command line string)
        preBuildSteps: # optional, default is 
        # Specify custom commands and trigger hooks (injects commands into jobs)
        customJobHooks: # optional, default is 
        # Run a custom job instead of the standard build automation for cloud runner (in yaml format with the keys image, secrets (name, value object array), command line string)
        customJob: # optional, default is 
        # The Cloud Formation stack name that must be setup before using this option.
        awsBaseStackName: # optional, default is game-ci
        # Either local, k8s or aws can be used to run builds on a remote cluster. Additional parameters must be configured.
        cloudRunnerCluster: # optional, default is local
        # Amount of CPU time to assign the remote build container
        cloudRunnerCpu: # optional, default is 
        # Amount of memory to assign the remote build container
        cloudRunnerMemory: # optional, default is 
        # A command run every time a file is pushed to cache, formatted with input file path and remote cache path
        cachePushOverrideCommand: # optional, default is 
        # A command run every time before a file is being pulled from cache, formatted with request cache file and destination path
        cachePullOverrideCommand: # optional, default is 
        # Comma separated list of input value names to read from "input override command"
        readInputFromOverrideList: # optional, default is 
        # Extend game ci by specifying a command to execute to pull input from external source e.g cloud provider secret managers
        readInputOverrideCommand: # optional, default is 
        # Cache key to indicate bucket for cache
        cacheKey: # optional, default is 
        # Use to specify a way to check depdency services health to enable resilient self-starting jobs
        checkDependencyHealthOverride: # optional, default is 
        # Use to specify a way to start depdency services health to enable resilient self-starting jobs
        startDependenciesOverride: # optional, default is 

    # copy asset bundles to mod folder, commit them
    
  build:
    name: Build & Analyze Mod
    runs-on: windows-latest
    needs: [build-unity-assemblies, build-asset-bundles]
    if: |
      always() &&
      (needs.check-paths-changed.outputs.generate_unitypackage == 'true' || 
      needs.check-paths-changed.outputs.build_asset_bundles == 'true' || 
      needs.check-paths-changed.outputs.build_mod == 'true')

    steps:
    - uses: actions/checkout@v2
      with:
        fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis
        
    - name: Add MSBuild to PATH
      uses: microsoft/setup-msbuild@v1
      
    - name: Setup VSTest.console.exe
      uses: darenm/Setup-VSTest@v1
      
    - name: Set up JDK 11
      uses: actions/setup-java@v1
      with:
        java-version: 1.11
        
    - name: Cache SonarCloud packages
      uses: actions/cache@v1
      with:
        path: ~\sonar\cache
        key: ${{ runner.os }}-sonar
        restore-keys: ${{ runner.os }}-sonar
        
    - name: Cache SonarCloud scanner
      id: cache-sonar-scanner
      uses: actions/cache@v1
      with:
        path: .\.sonar\scanner
        key: ${{ runner.os }}-sonar-scanner
        restore-keys: ${{ runner.os }}-sonar-scanner
        
    - name: Install SonarCloud scanner
      if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'
      shell: powershell
      run: |
        New-Item -Path .\.sonar\scanner -ItemType Directory
        dotnet tool update dotnet-sonarscanner --tool-path .\.sonar\scanner

    - name: Restore NuGet packages
      working-directory: ${{env.GITHUB_WORKSPACE}}
      run: nuget restore ${{env.SOLUTION_FILE_PATH}}
      
    #- name: Start SonarCloud Analysis
    #  env:
    #    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
    #    SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    #  run: .\.sonar\scanner\dotnet-sonarscanner begin /k:"MCBTay_XLGearModifier" /o:"mcbtay" /d:sonar.login="${{ secrets.SONAR_TOKEN }}" /d:sonar.host.url="https://sonarcloud.io" /d:sonar.cs.vstest.reportsPaths="**/*.trx" /d:sonar.cs.opencover.reportsPaths="**/coverage.opencover.xml"
        
    - name: MSBuild
      working-directory: ${{env.GITHUB_WORKSPACE}}
      shell: powershell
      run: |
        msbuild /m /p:Configuration=${{env.BUILD_CONFIGURATION}} ${{env.SOLUTION_FILE_PATH}}
        
    #- name: Stop SonarScanner Analysis
    #  env:
    #    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
    #    SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    #  run: .\.sonar\scanner\dotnet-sonarscanner end /d:sonar.login="${{ secrets.SONAR_TOKEN }}"
      
